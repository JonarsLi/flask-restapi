{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask-RESTAPI is an extension for Flask that is a database-agnostic framework library for creating REST APIs. It is a lightweight abstraction that works with your existing ORM/libraries. It use pydantic to validate and serialize data. OpenAPI document can be automatically generated through the python decorator and it supports swagger ui display. Pydantic are used to validate and serialize parameters. For details, please refer to the pydantic documentation . Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" )) Swagger API docs \u00b6 Now go to http://localhost:5000/docs","title":"Overview"},{"location":"#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"#swagger-api-docs","text":"Now go to http://localhost:5000/docs","title":"Swagger API docs"},{"location":"files/","text":"Introduction \u00b6 Form Decorator support upload files. Note Parameters will store the type of werkzeug.FileStorage . Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType , FileStorageType app = Flask ( __name__ ) api = Api ( app ) class UserFormSpec ( BaseModel ): name : str image : FileStorageType class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . form ( UserFormSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): \"\"\"Post a user name and image\"\"\" user_name = parameters . form . name image = parameters . form . image image . save ( \"Myimage.png\" ) return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Upload files"},{"location":"files/#introduction","text":"Form Decorator support upload files. Note Parameters will store the type of werkzeug.FileStorage .","title":"Introduction"},{"location":"files/#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType , FileStorageType app = Flask ( __name__ ) api = Api ( app ) class UserFormSpec ( BaseModel ): name : str image : FileStorageType class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . form ( UserFormSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): \"\"\"Post a user name and image\"\"\" user_name = parameters . form . name image = parameters . form . image image . save ( \"Myimage.png\" ) return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"function_based_view/","text":"Introduction \u00b6 If you don't want to use flask methodview, You can also use decorators in the case of function based view. Note If you want to output spec correctly, you must describe endpoint_name and method_name on decorators Example \u00b6 General from flask import Flask from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str @app . route ( \"/user\" ) @api . query ( UserGetSpec , endpoint = \"user_get\" , method_name = \"get\" ) @api . response ( UserResponseSpec , endpoint = \"user_get\" , method_name = \"get\" ) def user_get ( self , parameters : RequestParametersType ): user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) Blueprint from flask import Flask , Blueprint from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) bp = Blueprint ( \"user\" , import_name = __name__ ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str @bp . route ( \"/user\" ) @api . bp_map ( bp . name ) @api . query ( UserGetSpec , endpoint = \"user_get\" , method_name = \"get\" ) @api . response ( UserResponseSpec , endpoint = \"user_get\" , method_name = \"get\" ) def user_get ( self , parameters : RequestParametersType ): user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) app . register_blueprint ( bp )","title":"Function Based View"},{"location":"function_based_view/#introduction","text":"If you don't want to use flask methodview, You can also use decorators in the case of function based view. Note If you want to output spec correctly, you must describe endpoint_name and method_name on decorators","title":"Introduction"},{"location":"function_based_view/#example","text":"General from flask import Flask from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str @app . route ( \"/user\" ) @api . query ( UserGetSpec , endpoint = \"user_get\" , method_name = \"get\" ) @api . response ( UserResponseSpec , endpoint = \"user_get\" , method_name = \"get\" ) def user_get ( self , parameters : RequestParametersType ): user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) Blueprint from flask import Flask , Blueprint from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) bp = Blueprint ( \"user\" , import_name = __name__ ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str @bp . route ( \"/user\" ) @api . bp_map ( bp . name ) @api . query ( UserGetSpec , endpoint = \"user_get\" , method_name = \"get\" ) @api . response ( UserResponseSpec , endpoint = \"user_get\" , method_name = \"get\" ) def user_get ( self , parameters : RequestParametersType ): user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) app . register_blueprint ( bp )","title":"Example"},{"location":"install/","text":"Dependencies \u00b6 Python >= 3.7 Flask >= 2.0.1 pydantic >= 1.8.2 Install \u00b6 pip install flask-restapi","title":"Install"},{"location":"install/#dependencies","text":"Python >= 3.7 Flask >= 2.0.1 pydantic >= 1.8.2","title":"Dependencies"},{"location":"install/#install","text":"pip install flask-restapi","title":"Install"},{"location":"openapi/","text":"API parameters \u00b6 Flask-RESTAPI automatically generates an OpenAPI documentation. And you can set the parameters of Open API Sepc through Flask config. OPENAPI_VERSION This string MUST be the semantic version number of the OpenAPI Specification version that the OpenAPI document uses. API_TITLE Title of the API. API_VERSION The version of the OpenAPI document. SPEC_URL Spec json url. SWAGGER_UI_URL Swagger ui url.","title":"OpenAPI"},{"location":"openapi/#api-parameters","text":"Flask-RESTAPI automatically generates an OpenAPI documentation. And you can set the parameters of Open API Sepc through Flask config. OPENAPI_VERSION This string MUST be the semantic version number of the OpenAPI Specification version that the OpenAPI document uses. API_TITLE Title of the API. API_VERSION The version of the OpenAPI document. SPEC_URL Spec json url. SWAGGER_UI_URL Swagger ui url.","title":"API parameters"},{"location":"quickstart/","text":"Initializing Extensions \u00b6 Initialize flask and api instance from flask import Flask from flask_restapi import Api app = Flask ( __name__ ) api = Api ( app ) Create sepc model \u00b6 Create parameter and response for spec model. from flask import Flask from pydantic import BaseModel from flask_restapi import Api app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str Create flask view \u00b6 Create flask MethodView and add route url to flask. Although it can be used without MethodView, but is not recommended. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" )) Use decorators \u00b6 You can use decorators to make spec document and validate request parameters. When using decorators, you don\u2019t need to care about the order. Decorator Description Path Receive request url path Query Receive request query string Header Receive request header Body Receive request body Form Receive request form data Auth Receive authorization token by headers Response Make response schema to spec document from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" )) Get parameters \u00b6 You can get request args from \"parameters\". except for response, all decorators will store the initialized objects on request.parameters. <Decorator name> . Note Decorator will pass request.parameters to the function. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" )) Return response \u00b6 If you return an object of BaseModel type, the response decorator will automatically convert it into a dictionary. When flask captures a dictionary, it will be processed by jsonify and output. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" )) Interactive API docs \u00b6 Swagger ui docs => http://localhost:5000/docs . If you want to access spec.json, you can go to http://localhost/api/sepc.json","title":"Quickstart"},{"location":"quickstart/#initializing-extensions","text":"Initialize flask and api instance from flask import Flask from flask_restapi import Api app = Flask ( __name__ ) api = Api ( app )","title":"Initializing Extensions"},{"location":"quickstart/#create-sepc-model","text":"Create parameter and response for spec model. from flask import Flask from pydantic import BaseModel from flask_restapi import Api app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str","title":"Create sepc model"},{"location":"quickstart/#create-flask-view","text":"Create flask MethodView and add route url to flask. Although it can be used without MethodView, but is not recommended. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Create flask view"},{"location":"quickstart/#use-decorators","text":"You can use decorators to make spec document and validate request parameters. When using decorators, you don\u2019t need to care about the order. Decorator Description Path Receive request url path Query Receive request query string Header Receive request header Body Receive request body Form Receive request form data Auth Receive authorization token by headers Response Make response schema to spec document from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Use decorators"},{"location":"quickstart/#get-parameters","text":"You can get request args from \"parameters\". except for response, all decorators will store the initialized objects on request.parameters. <Decorator name> . Note Decorator will pass request.parameters to the function. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Get parameters"},{"location":"quickstart/#return-response","text":"If you return an object of BaseModel type, the response decorator will automatically convert it into a dictionary. When flask captures a dictionary, it will be processed by jsonify and output. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Return response"},{"location":"quickstart/#interactive-api-docs","text":"Swagger ui docs => http://localhost:5000/docs . If you want to access spec.json, you can go to http://localhost/api/sepc.json","title":"Interactive API docs"},{"location":"response/","text":"Handling error \u00b6 To return HTTP responses with errors to the client you use ApiException . Note If you don\u2019t want to add additional error specs to spec.json, you can not use response decorators for error responses. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType , ApiException app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class UserAuthErrorSepc ( BaseModel ): description : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) @api . response ( UserAuthErrorSepc , code = 401 ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password if user_password != \"hello\" : raise ApiException ( 401 , description = \"Password is incorrect\" ) return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" )) Add response header \u00b6 f you want to add a fixed header to the response, you can add it through the parameter headers of the response decorator. However, if you want to dynamically add response headers, you can add extra = allow to the response spec config. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class Config : extra = \"allow\" class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec , headers = { \"fix-header\" : \"is fix header\" }) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name headers = { \"dynamic-header\" : \"is dynamic header\" } return UserResponseSpec ( id = 1 , name = user_name , headers = headers ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Response"},{"location":"response/#handling-error","text":"To return HTTP responses with errors to the client you use ApiException . Note If you don\u2019t want to add additional error specs to spec.json, you can not use response decorators for error responses. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType , ApiException app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class UserAuthErrorSepc ( BaseModel ): description : str class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) @api . response ( UserAuthErrorSepc , code = 401 ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password if user_password != \"hello\" : raise ApiException ( 401 , description = \"Password is incorrect\" ) return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Handling error"},{"location":"response/#add-response-header","text":"f you want to add a fixed header to the response, you can add it through the parameter headers of the response decorator. However, if you want to dynamically add response headers, you can add extra = allow to the response spec config. from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class Config : extra = \"allow\" class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec , headers = { \"fix-header\" : \"is fix header\" }) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name headers = { \"dynamic-header\" : \"is dynamic header\" } return UserResponseSpec ( id = 1 , name = user_name , headers = headers ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Add response header"},{"location":"tag/","text":"Introduction \u00b6 Decorators (path, query, title, body, form) have tag parameters, which can be used to distinguish API operations. Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType , TagModel app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec , tag = TagModel ( name = \"user\" , description = \"User tag\" )) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Tag"},{"location":"tag/#introduction","text":"Decorators (path, query, title, body, form) have tag parameters, which can be used to distinguish API operations.","title":"Introduction"},{"location":"tag/#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType , TagModel app = Flask ( __name__ ) api = Api ( app ) class UserGetSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserGetSpec , tag = TagModel ( name = \"user\" , description = \"User tag\" )) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"api/core/","text":"flask_restapi.core.Api ( SpecMixin , AuthMixin , HandlerMixin ) \u00b6 Source code in flask_restapi/core.py class Api ( SpecMixin , AuthMixin , HandlerMixin ): def __init__ ( self , app : Flask = None ) -> None : self . spec = Spec () self . app = app if app is not None : self . init_app ( app ) def init_app ( self , app : Flask ) -> None : self . app = app super () . init_app () self . app . before_first_request ( self . _register_spec ) with self . app . app_context (): self . _register_blueprint () self . _register_handlers () self . app . cli . add_command ( commands . api_cli ) def bp_map ( self , blueprint_name : str = None , endpoint_name : str = None ): \"\"\"Bind the URL endpoint to the blueprint name. Args: blueprint_name (str, optional): Flask blueprint name. Defaults to None. endpoint_name (str, optional): Flask url endpoint name. Defaults to None. \"\"\" def decorator ( cls ): blueprint_map = BlueprintMap ( endpoint_name = endpoint_name or cls . __name__ . lower (), blueprint_name = blueprint_name ) self . spec . blueprint_maps . append ( blueprint_map ) return cls return decorator def header ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request url path. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"header\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () _headers = dict (( k . lower (), v ) for k , v in request . headers . items ()) request . parameters . header = schema ( ** _headers ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def path ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request url path Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"path\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () request . parameters . path = schema ( ** request . view_args ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def query ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request query string. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"query\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () req_args = request . args . to_dict ( flat = False ) normalize_query = {} for key , value in req_args . items (): if len ( value ) > 1 : normalize_query . update ({ key : value }) else : normalize_query . update ({ key : value [ 0 ]}) request . parameters . query = schema ( ** normalize_query ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def body ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"application/json\" ], tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request body. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type. Defaults to \"application/json\". tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_body ( schema , ep , _method_name , content_type , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () body : dict = request . get_json () or dict () request . parameters . body = schema ( ** body ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def form ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"multipart/form-data\" ], tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request form data. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type]. Defaults to \"application/json\". tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_body ( schema , ep , _method_name , content_type , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () _form = {} if request . files . to_dict (): _form . update ( request . files . to_dict ()) if request . form . to_dict (): _form . update ( request . form . to_dict ()) request . parameters . form = schema ( ** _form ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def auth ( self , endpoint : str = None , method_name : str = None ): \"\"\"Receive authorization token by headers. This auth decorator will get the Authorization of Flask request.headers and mark the endpoint on the spec as requiring verification. Args: endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ self . spec . store_auth ( ep , _method_name ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () auth_header = request . headers . get ( \"Authorization\" ) if auth_header is not None : if \"Bearer\" in auth_header : _token = auth_header . split ( \" \" )[ 1 ] request . parameters . auth = _token else : request . parameters . auth = auth_header return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def response ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"application/json\" ], headers : Dict [ str , Any ] = None , code : int = 200 , default_validation_error : bool = True , ): \"\"\"Make response schema to spec document and auto converted to dictionary. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type]. Defaults to \"application/json\". headers (Dict[str, Any], optional): Response additional headers. Defaults to None. code (int, optional): HTTP status code. Defaults to 200. default_validation_error (bool, optional): Whether to show on spec. Defaults to True. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ self . spec . store_responses ( code , schema , ep , _method_name , content_type ) if default_validation_error : self . spec . store_responses ( 422 , ValidationErrorResponses , ep , _method_name , content_type ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () result = current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) if isinstance ( result , BaseModel ): response = make_response ( result . dict ( exclude = { \"headers\" }), code ) else : response = make_response ( result , code ) # Add header from result if hasattr ( result , \"headers\" ): if isinstance ( result . headers , dict ): for key , value in result . headers . items (): response . headers [ key ] = value # Add header from decorator if isinstance ( headers , dict ): for key , value in headers . items (): response . headers [ key ] = value return response return wrapper return decorator def _get_request_parameters ( self ) -> RequestParametersType : if not hasattr ( request , \"parameters\" ): request . parameters = RequestParametersType () return request . parameters def _generate_endpoint ( self , endpoint : str ) -> str : return endpoint . split ( \".\" )[ 0 ] . lower () auth ( self , endpoint = None , method_name = None ) \u00b6 Receive authorization token by headers. This auth decorator will get the Authorization of Flask request.headers and mark the endpoint on the spec as requiring verification. Parameters: Name Type Description Default endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None Source code in flask_restapi/core.py def auth ( self , endpoint : str = None , method_name : str = None ): \"\"\"Receive authorization token by headers. This auth decorator will get the Authorization of Flask request.headers and mark the endpoint on the spec as requiring verification. Args: endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ self . spec . store_auth ( ep , _method_name ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () auth_header = request . headers . get ( \"Authorization\" ) if auth_header is not None : if \"Bearer\" in auth_header : _token = auth_header . split ( \" \" )[ 1 ] request . parameters . auth = _token else : request . parameters . auth = auth_header return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator body ( self , schema , endpoint = None , method_name = None , content_type = [ 'application/json' ], tag = None , summary = None ) \u00b6 Receive request body. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None content_type list HTTP content-type. Defaults to \"application/json\". ['application/json'] tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def body ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"application/json\" ], tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request body. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type. Defaults to \"application/json\". tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_body ( schema , ep , _method_name , content_type , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () body : dict = request . get_json () or dict () request . parameters . body = schema ( ** body ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator bp_map ( self , blueprint_name = None , endpoint_name = None ) \u00b6 Bind the URL endpoint to the blueprint name. Parameters: Name Type Description Default blueprint_name str Flask blueprint name. Defaults to None. None endpoint_name str Flask url endpoint name. Defaults to None. None Source code in flask_restapi/core.py def bp_map ( self , blueprint_name : str = None , endpoint_name : str = None ): \"\"\"Bind the URL endpoint to the blueprint name. Args: blueprint_name (str, optional): Flask blueprint name. Defaults to None. endpoint_name (str, optional): Flask url endpoint name. Defaults to None. \"\"\" def decorator ( cls ): blueprint_map = BlueprintMap ( endpoint_name = endpoint_name or cls . __name__ . lower (), blueprint_name = blueprint_name ) self . spec . blueprint_maps . append ( blueprint_map ) return cls return decorator form ( self , schema , endpoint = None , method_name = None , content_type = [ 'multipart/form-data' ], tag = None , summary = None ) \u00b6 Receive request form data. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None content_type list HTTP content-type]. Defaults to \"application/json\". ['multipart/form-data'] tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def form ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"multipart/form-data\" ], tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request form data. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type]. Defaults to \"application/json\". tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_body ( schema , ep , _method_name , content_type , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () _form = {} if request . files . to_dict (): _form . update ( request . files . to_dict ()) if request . form . to_dict (): _form . update ( request . form . to_dict ()) request . parameters . form = schema ( ** _form ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator header ( self , schema , endpoint = None , method_name = None , tag = None , summary = None ) \u00b6 Receive request url path. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def header ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request url path. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"header\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () _headers = dict (( k . lower (), v ) for k , v in request . headers . items ()) request . parameters . header = schema ( ** _headers ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator path ( self , schema , endpoint = None , method_name = None , tag = None , summary = None ) \u00b6 Receive request url path Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def path ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request url path Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"path\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () request . parameters . path = schema ( ** request . view_args ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator query ( self , schema , endpoint = None , method_name = None , tag = None , summary = None ) \u00b6 Receive request query string. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def query ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request query string. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"query\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () req_args = request . args . to_dict ( flat = False ) normalize_query = {} for key , value in req_args . items (): if len ( value ) > 1 : normalize_query . update ({ key : value }) else : normalize_query . update ({ key : value [ 0 ]}) request . parameters . query = schema ( ** normalize_query ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator response ( self , schema , endpoint = None , method_name = None , content_type = [ 'application/json' ], headers = None , code = 200 , default_validation_error = True ) \u00b6 Make response schema to spec document and auto converted to dictionary. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None content_type list HTTP content-type]. Defaults to \"application/json\". ['application/json'] headers Dict[str, Any] Response additional headers. Defaults to None. None code int HTTP status code. Defaults to 200. 200 default_validation_error bool Whether to show on spec. Defaults to True. True Source code in flask_restapi/core.py def response ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"application/json\" ], headers : Dict [ str , Any ] = None , code : int = 200 , default_validation_error : bool = True , ): \"\"\"Make response schema to spec document and auto converted to dictionary. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type]. Defaults to \"application/json\". headers (Dict[str, Any], optional): Response additional headers. Defaults to None. code (int, optional): HTTP status code. Defaults to 200. default_validation_error (bool, optional): Whether to show on spec. Defaults to True. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ self . spec . store_responses ( code , schema , ep , _method_name , content_type ) if default_validation_error : self . spec . store_responses ( 422 , ValidationErrorResponses , ep , _method_name , content_type ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () result = current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) if isinstance ( result , BaseModel ): response = make_response ( result . dict ( exclude = { \"headers\" }), code ) else : response = make_response ( result , code ) # Add header from result if hasattr ( result , \"headers\" ): if isinstance ( result . headers , dict ): for key , value in result . headers . items (): response . headers [ key ] = value # Add header from decorator if isinstance ( headers , dict ): for key , value in headers . items (): response . headers [ key ] = value return response return wrapper return decorator","title":"Core"},{"location":"api/core/#flask_restapi.core.Api","text":"Source code in flask_restapi/core.py class Api ( SpecMixin , AuthMixin , HandlerMixin ): def __init__ ( self , app : Flask = None ) -> None : self . spec = Spec () self . app = app if app is not None : self . init_app ( app ) def init_app ( self , app : Flask ) -> None : self . app = app super () . init_app () self . app . before_first_request ( self . _register_spec ) with self . app . app_context (): self . _register_blueprint () self . _register_handlers () self . app . cli . add_command ( commands . api_cli ) def bp_map ( self , blueprint_name : str = None , endpoint_name : str = None ): \"\"\"Bind the URL endpoint to the blueprint name. Args: blueprint_name (str, optional): Flask blueprint name. Defaults to None. endpoint_name (str, optional): Flask url endpoint name. Defaults to None. \"\"\" def decorator ( cls ): blueprint_map = BlueprintMap ( endpoint_name = endpoint_name or cls . __name__ . lower (), blueprint_name = blueprint_name ) self . spec . blueprint_maps . append ( blueprint_map ) return cls return decorator def header ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request url path. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"header\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () _headers = dict (( k . lower (), v ) for k , v in request . headers . items ()) request . parameters . header = schema ( ** _headers ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def path ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request url path Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"path\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () request . parameters . path = schema ( ** request . view_args ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def query ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request query string. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"query\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () req_args = request . args . to_dict ( flat = False ) normalize_query = {} for key , value in req_args . items (): if len ( value ) > 1 : normalize_query . update ({ key : value }) else : normalize_query . update ({ key : value [ 0 ]}) request . parameters . query = schema ( ** normalize_query ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def body ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"application/json\" ], tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request body. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type. Defaults to \"application/json\". tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_body ( schema , ep , _method_name , content_type , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () body : dict = request . get_json () or dict () request . parameters . body = schema ( ** body ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def form ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"multipart/form-data\" ], tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request form data. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type]. Defaults to \"application/json\". tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_body ( schema , ep , _method_name , content_type , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () _form = {} if request . files . to_dict (): _form . update ( request . files . to_dict ()) if request . form . to_dict (): _form . update ( request . form . to_dict ()) request . parameters . form = schema ( ** _form ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def auth ( self , endpoint : str = None , method_name : str = None ): \"\"\"Receive authorization token by headers. This auth decorator will get the Authorization of Flask request.headers and mark the endpoint on the spec as requiring verification. Args: endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ self . spec . store_auth ( ep , _method_name ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () auth_header = request . headers . get ( \"Authorization\" ) if auth_header is not None : if \"Bearer\" in auth_header : _token = auth_header . split ( \" \" )[ 1 ] request . parameters . auth = _token else : request . parameters . auth = auth_header return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator def response ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"application/json\" ], headers : Dict [ str , Any ] = None , code : int = 200 , default_validation_error : bool = True , ): \"\"\"Make response schema to spec document and auto converted to dictionary. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type]. Defaults to \"application/json\". headers (Dict[str, Any], optional): Response additional headers. Defaults to None. code (int, optional): HTTP status code. Defaults to 200. default_validation_error (bool, optional): Whether to show on spec. Defaults to True. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ self . spec . store_responses ( code , schema , ep , _method_name , content_type ) if default_validation_error : self . spec . store_responses ( 422 , ValidationErrorResponses , ep , _method_name , content_type ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () result = current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) if isinstance ( result , BaseModel ): response = make_response ( result . dict ( exclude = { \"headers\" }), code ) else : response = make_response ( result , code ) # Add header from result if hasattr ( result , \"headers\" ): if isinstance ( result . headers , dict ): for key , value in result . headers . items (): response . headers [ key ] = value # Add header from decorator if isinstance ( headers , dict ): for key , value in headers . items (): response . headers [ key ] = value return response return wrapper return decorator def _get_request_parameters ( self ) -> RequestParametersType : if not hasattr ( request , \"parameters\" ): request . parameters = RequestParametersType () return request . parameters def _generate_endpoint ( self , endpoint : str ) -> str : return endpoint . split ( \".\" )[ 0 ] . lower ()","title":"Api"},{"location":"api/core/#flask_restapi.core.Api.auth","text":"Receive authorization token by headers. This auth decorator will get the Authorization of Flask request.headers and mark the endpoint on the spec as requiring verification. Parameters: Name Type Description Default endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None Source code in flask_restapi/core.py def auth ( self , endpoint : str = None , method_name : str = None ): \"\"\"Receive authorization token by headers. This auth decorator will get the Authorization of Flask request.headers and mark the endpoint on the spec as requiring verification. Args: endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ self . spec . store_auth ( ep , _method_name ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () auth_header = request . headers . get ( \"Authorization\" ) if auth_header is not None : if \"Bearer\" in auth_header : _token = auth_header . split ( \" \" )[ 1 ] request . parameters . auth = _token else : request . parameters . auth = auth_header return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator","title":"auth()"},{"location":"api/core/#flask_restapi.core.Api.body","text":"Receive request body. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None content_type list HTTP content-type. Defaults to \"application/json\". ['application/json'] tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def body ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"application/json\" ], tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request body. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type. Defaults to \"application/json\". tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_body ( schema , ep , _method_name , content_type , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () body : dict = request . get_json () or dict () request . parameters . body = schema ( ** body ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator","title":"body()"},{"location":"api/core/#flask_restapi.core.Api.bp_map","text":"Bind the URL endpoint to the blueprint name. Parameters: Name Type Description Default blueprint_name str Flask blueprint name. Defaults to None. None endpoint_name str Flask url endpoint name. Defaults to None. None Source code in flask_restapi/core.py def bp_map ( self , blueprint_name : str = None , endpoint_name : str = None ): \"\"\"Bind the URL endpoint to the blueprint name. Args: blueprint_name (str, optional): Flask blueprint name. Defaults to None. endpoint_name (str, optional): Flask url endpoint name. Defaults to None. \"\"\" def decorator ( cls ): blueprint_map = BlueprintMap ( endpoint_name = endpoint_name or cls . __name__ . lower (), blueprint_name = blueprint_name ) self . spec . blueprint_maps . append ( blueprint_map ) return cls return decorator","title":"bp_map()"},{"location":"api/core/#flask_restapi.core.Api.form","text":"Receive request form data. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None content_type list HTTP content-type]. Defaults to \"application/json\". ['multipart/form-data'] tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def form ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"multipart/form-data\" ], tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request form data. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type]. Defaults to \"application/json\". tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_body ( schema , ep , _method_name , content_type , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () _form = {} if request . files . to_dict (): _form . update ( request . files . to_dict ()) if request . form . to_dict (): _form . update ( request . form . to_dict ()) request . parameters . form = schema ( ** _form ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator","title":"form()"},{"location":"api/core/#flask_restapi.core.Api.header","text":"Receive request url path. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def header ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request url path. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"header\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () _headers = dict (( k . lower (), v ) for k , v in request . headers . items ()) request . parameters . header = schema ( ** _headers ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator","title":"header()"},{"location":"api/core/#flask_restapi.core.Api.path","text":"Receive request url path Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def path ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request url path Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"path\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () request . parameters . path = schema ( ** request . view_args ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator","title":"path()"},{"location":"api/core/#flask_restapi.core.Api.query","text":"Receive request query string. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None tag Type[TagModel] List of tags to each API operation. Defaults to None. None summary str Override spec summary. Defaults to None. None Source code in flask_restapi/core.py def query ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , tag : Type [ TagModel ] = None , summary : str = None , ): \"\"\"Receive request query string. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. tag (Type[TagModel], optional): List of tags to each API operation. Defaults to None. summary (str, optional): Override spec summary. Defaults to None. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ _summary = summary or func . __doc__ or None self . spec . store_parameters ( \"query\" , schema , ep , _method_name , tag , _summary ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () req_args = request . args . to_dict ( flat = False ) normalize_query = {} for key , value in req_args . items (): if len ( value ) > 1 : normalize_query . update ({ key : value }) else : normalize_query . update ({ key : value [ 0 ]}) request . parameters . query = schema ( ** normalize_query ) return current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) return wrapper return decorator","title":"query()"},{"location":"api/core/#flask_restapi.core.Api.response","text":"Make response schema to spec document and auto converted to dictionary. Parameters: Name Type Description Default schema Type[BaseModel] Models are classes which inherit from BaseModel . required endpoint str Flask url endpoint name. Defaults to None. None method_name str Endpoint method name. Defaults to None. None content_type list HTTP content-type]. Defaults to \"application/json\". ['application/json'] headers Dict[str, Any] Response additional headers. Defaults to None. None code int HTTP status code. Defaults to 200. 200 default_validation_error bool Whether to show on spec. Defaults to True. True Source code in flask_restapi/core.py def response ( self , schema : Type [ BaseModel ], endpoint : str = None , method_name : str = None , content_type : list = [ \"application/json\" ], headers : Dict [ str , Any ] = None , code : int = 200 , default_validation_error : bool = True , ): \"\"\"Make response schema to spec document and auto converted to dictionary. Args: schema (Type[BaseModel]): Models are classes which inherit from `BaseModel`. endpoint (str, optional): Flask url endpoint name. Defaults to None. method_name (str, optional): Endpoint method name. Defaults to None. content_type (list, optional): HTTP content-type]. Defaults to \"application/json\". headers (Dict[str, Any], optional): Response additional headers. Defaults to None. code (int, optional): HTTP status code. Defaults to 200. default_validation_error (bool, optional): Whether to show on spec. Defaults to True. \"\"\" def decorator ( func ): ep = endpoint if endpoint else self . _generate_endpoint ( func . __qualname__ ) _method_name = method_name or func . __name__ self . spec . store_responses ( code , schema , ep , _method_name , content_type ) if default_validation_error : self . spec . store_responses ( 422 , ValidationErrorResponses , ep , _method_name , content_type ) @functools . wraps ( func ) def wrapper ( func_self = None , * args , ** kwargs ): request . parameters = self . _get_request_parameters () result = current_app . ensure_sync ( func )( func_self , request . parameters , ** kwargs ) if isinstance ( result , BaseModel ): response = make_response ( result . dict ( exclude = { \"headers\" }), code ) else : response = make_response ( result , code ) # Add header from result if hasattr ( result , \"headers\" ): if isinstance ( result . headers , dict ): for key , value in result . headers . items (): response . headers [ key ] = value # Add header from decorator if isinstance ( headers , dict ): for key , value in headers . items (): response . headers [ key ] = value return response return wrapper return decorator","title":"response()"},{"location":"api/exceptions/","text":"flask_restapi.exceptions.ApiException ( Exception ) \u00b6 Source code in flask_restapi/exceptions.py class ApiException ( Exception ): def __init__ ( self , http_code : int , ** options ) -> None : \"\"\"HTTP responses with errors to the client Args: http_code (int): HTTP response status code. \"\"\" self . http_code = http_code for key , value in options . items (): setattr ( self , key , value ) def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Convert all attributes to dictionary and exclude http_code of the key. Returns: All attributes but excluding http_code \"\"\" return self . __dict__ def to_json ( self ) -> str : \"\"\"Convert all attributes to json and exclude http_code of the key. Returns: All attributes but excluding http_code \"\"\" return json . dumps ( self . __dict__ ) __init__ ( self , http_code , ** options ) special \u00b6 HTTP responses with errors to the client Parameters: Name Type Description Default http_code int HTTP response status code. required Source code in flask_restapi/exceptions.py def __init__ ( self , http_code : int , ** options ) -> None : \"\"\"HTTP responses with errors to the client Args: http_code (int): HTTP response status code. \"\"\" self . http_code = http_code for key , value in options . items (): setattr ( self , key , value ) to_dict ( self ) \u00b6 Convert all attributes to dictionary and exclude http_code of the key. Returns: Type Description Dict[str, Any] All attributes but excluding http_code Source code in flask_restapi/exceptions.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Convert all attributes to dictionary and exclude http_code of the key. Returns: All attributes but excluding http_code \"\"\" return self . __dict__ to_json ( self ) \u00b6 Convert all attributes to json and exclude http_code of the key. Returns: Type Description str All attributes but excluding http_code Source code in flask_restapi/exceptions.py def to_json ( self ) -> str : \"\"\"Convert all attributes to json and exclude http_code of the key. Returns: All attributes but excluding http_code \"\"\" return json . dumps ( self . __dict__ )","title":"Exceptions"},{"location":"api/exceptions/#flask_restapi.exceptions.ApiException","text":"Source code in flask_restapi/exceptions.py class ApiException ( Exception ): def __init__ ( self , http_code : int , ** options ) -> None : \"\"\"HTTP responses with errors to the client Args: http_code (int): HTTP response status code. \"\"\" self . http_code = http_code for key , value in options . items (): setattr ( self , key , value ) def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Convert all attributes to dictionary and exclude http_code of the key. Returns: All attributes but excluding http_code \"\"\" return self . __dict__ def to_json ( self ) -> str : \"\"\"Convert all attributes to json and exclude http_code of the key. Returns: All attributes but excluding http_code \"\"\" return json . dumps ( self . __dict__ )","title":"ApiException"},{"location":"api/exceptions/#flask_restapi.exceptions.ApiException.__init__","text":"HTTP responses with errors to the client Parameters: Name Type Description Default http_code int HTTP response status code. required Source code in flask_restapi/exceptions.py def __init__ ( self , http_code : int , ** options ) -> None : \"\"\"HTTP responses with errors to the client Args: http_code (int): HTTP response status code. \"\"\" self . http_code = http_code for key , value in options . items (): setattr ( self , key , value )","title":"__init__()"},{"location":"api/exceptions/#flask_restapi.exceptions.ApiException.to_dict","text":"Convert all attributes to dictionary and exclude http_code of the key. Returns: Type Description Dict[str, Any] All attributes but excluding http_code Source code in flask_restapi/exceptions.py def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Convert all attributes to dictionary and exclude http_code of the key. Returns: All attributes but excluding http_code \"\"\" return self . __dict__","title":"to_dict()"},{"location":"api/exceptions/#flask_restapi.exceptions.ApiException.to_json","text":"Convert all attributes to json and exclude http_code of the key. Returns: Type Description str All attributes but excluding http_code Source code in flask_restapi/exceptions.py def to_json ( self ) -> str : \"\"\"Convert all attributes to json and exclude http_code of the key. Returns: All attributes but excluding http_code \"\"\" return json . dumps ( self . __dict__ )","title":"to_json()"},{"location":"decorators/auth/","text":"Introduction \u00b6 You can use auth decorator to receive authorization token by headers. This auth decorator will get the Authorization of Flask request.headers and mark the endpoint on the spec as requiring verification. Note If Authorization prefix contains \"Bearer\", it will be automatically removed Step \u00b6 Use auth decorator Get token from parameters.auth Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserBodySpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . auth () @api . body ( UserBodySpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . body . name token = parameters . auth return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Auth"},{"location":"decorators/auth/#introduction","text":"You can use auth decorator to receive authorization token by headers. This auth decorator will get the Authorization of Flask request.headers and mark the endpoint on the spec as requiring verification. Note If Authorization prefix contains \"Bearer\", it will be automatically removed","title":"Introduction"},{"location":"decorators/auth/#step","text":"Use auth decorator Get token from parameters.auth","title":"Step"},{"location":"decorators/auth/#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserBodySpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . auth () @api . body ( UserBodySpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . body . name token = parameters . auth return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"decorators/body/","text":"Introduction \u00b6 You can use body decorator to receive request body. Note content-type: application/json Step \u00b6 Create spec and inherit BaseModel Use body decorator Get body from parameters.body Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserBodySpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . body ( UserBodySpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . body . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Body"},{"location":"decorators/body/#introduction","text":"You can use body decorator to receive request body. Note content-type: application/json","title":"Introduction"},{"location":"decorators/body/#step","text":"Create spec and inherit BaseModel Use body decorator Get body from parameters.body","title":"Step"},{"location":"decorators/body/#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserBodySpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . body ( UserBodySpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . body . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"decorators/bp_map/","text":"Introduction \u00b6 If you want to use flask blueprint, in order to bind the URL endpoint to the blueprint name, you must add the bp_map decorator to the class. Example \u00b6 from flask import Flask , Blueprint from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) bp = Blueprint ( \"user\" , import_name = __name__ ) class UserGetSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str @api . bp_map ( bp . name ) class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) bp . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" )) app . register_blueprint ( bp )","title":"Blueprint Map"},{"location":"decorators/bp_map/#introduction","text":"If you want to use flask blueprint, in order to bind the URL endpoint to the blueprint name, you must add the bp_map decorator to the class.","title":"Introduction"},{"location":"decorators/bp_map/#example","text":"from flask import Flask , Blueprint from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) bp = Blueprint ( \"user\" , import_name = __name__ ) class UserGetSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str @api . bp_map ( bp . name ) class User ( MethodView ): @api . query ( UserGetSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) bp . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" )) app . register_blueprint ( bp )","title":"Example"},{"location":"decorators/form/","text":"Introduction \u00b6 You can use form decorator to receive request form data. Note content-type: multipart/form-data Step \u00b6 Create spec and inherit BaseModel Use form decorator Get form from parameters.form Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserFormSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . form ( UserFormSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . form . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Form"},{"location":"decorators/form/#introduction","text":"You can use form decorator to receive request form data. Note content-type: multipart/form-data","title":"Introduction"},{"location":"decorators/form/#step","text":"Create spec and inherit BaseModel Use form decorator Get form from parameters.form","title":"Step"},{"location":"decorators/form/#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserFormSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . form ( UserFormSpec ) @api . response ( UserResponseSpec ) def post ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . form . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"decorators/header/","text":"Introduction \u00b6 You can use header decorator to receive request header. From RFC 2616 - \"Hypertext Transfer Protocol -- HTTP/1.1\", Section 4.2, \"Message Headers\": Each header field consists of a name followed by a colon (\":\") and the field value. Field names are case-insensitive. Note Please use lowercase to spec attribute. Step \u00b6 Create spec and inherit BaseModel Use header decorator Get header from parameters.header Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserHeaderSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . header ( UserHeaderSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . header . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Header"},{"location":"decorators/header/#introduction","text":"You can use header decorator to receive request header. From RFC 2616 - \"Hypertext Transfer Protocol -- HTTP/1.1\", Section 4.2, \"Message Headers\": Each header field consists of a name followed by a colon (\":\") and the field value. Field names are case-insensitive. Note Please use lowercase to spec attribute.","title":"Introduction"},{"location":"decorators/header/#step","text":"Create spec and inherit BaseModel Use header decorator Get header from parameters.header","title":"Step"},{"location":"decorators/header/#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserHeaderSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . header ( UserHeaderSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . header . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"decorators/path/","text":"Introduction \u00b6 You can use path decorator to receive request url path. Step \u00b6 Create spec and inherit BaseModel Use path decorator Get path from parameters.path When registering the flask route, add the keyword argument Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserPathSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . path ( UserPathSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . path . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user/<string:name>\" , view_func = User . as_view ( \"user\" ))","title":"Path"},{"location":"decorators/path/#introduction","text":"You can use path decorator to receive request url path.","title":"Introduction"},{"location":"decorators/path/#step","text":"Create spec and inherit BaseModel Use path decorator Get path from parameters.path When registering the flask route, add the keyword argument","title":"Step"},{"location":"decorators/path/#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserPathSpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . path ( UserPathSpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . path . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user/<string:name>\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"decorators/query/","text":"Introduction \u00b6 You can use query decorator to receive request query string. Step \u00b6 Create spec and inherit BaseModel Use query decorator Get query from parameters.query Example \u00b6 from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserQuerySpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserQuerySpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Query"},{"location":"decorators/query/#introduction","text":"You can use query decorator to receive request query string.","title":"Introduction"},{"location":"decorators/query/#step","text":"Create spec and inherit BaseModel Use query decorator Get query from parameters.query","title":"Step"},{"location":"decorators/query/#example","text":"from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType app = Flask ( __name__ ) api = Api ( app ) class UserQuerySpec ( BaseModel ): name : str class UserResponseSpec ( BaseModel ): id : int name : str class User ( MethodView ): @api . query ( UserQuerySpec ) @api . response ( UserResponseSpec ) def get ( self , parameters : RequestParametersType ): \"\"\"Get a user name and id\"\"\" user_name = parameters . query . name return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Example"},{"location":"decorators/response/","text":"Introduction \u00b6 You can use response decorator to make response schema to spec document. If you need multiple response specification documents, you can use multiple response decorators to achieve. Note If it detects that the return type is Pydantic BaseModel, it will be automatically converted to dictionary. Step \u00b6 Create spec and inherit BaseModel Use response decorator Return response from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType , ApiException app = Flask ( __name__ ) api = Api ( app ) class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class UserAuthErrorSepc ( BaseModel ): description : str class User ( MethodView ): @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) @api . response ( UserAuthErrorSepc , code = 401 ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password if user_password != \"hello\" : raise ApiException ( 401 , description = \"Password is incorrect\" ) return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Response"},{"location":"decorators/response/#introduction","text":"You can use response decorator to make response schema to spec document. If you need multiple response specification documents, you can use multiple response decorators to achieve. Note If it detects that the return type is Pydantic BaseModel, it will be automatically converted to dictionary.","title":"Introduction"},{"location":"decorators/response/#step","text":"Create spec and inherit BaseModel Use response decorator Return response from flask import Flask from flask.views import MethodView from pydantic import BaseModel from flask_restapi import Api , RequestParametersType , ApiException app = Flask ( __name__ ) api = Api ( app ) class UserCreateSpec ( BaseModel ): name : str password : str class UserResponseSpec ( BaseModel ): id : int name : str class UserAuthErrorSepc ( BaseModel ): description : str class User ( MethodView ): @api . body ( UserCreateSpec ) @api . response ( UserResponseSpec ) @api . response ( UserAuthErrorSepc , code = 401 ) def post ( self , parameters : RequestParametersType ): user_name = parameters . body . name user_password = parameters . body . password if user_password != \"hello\" : raise ApiException ( 401 , description = \"Password is incorrect\" ) return UserResponseSpec ( id = 1 , name = user_name ) app . add_url_rule ( \"/user\" , view_func = User . as_view ( \"user\" ))","title":"Step"}]}